#+TITLE:Language Tests

I test various language functionalities and usage experience. I want to find a language which will significantly increase my productivity over C++, without having significant drawbacks.

I used to think C++ was the ideal language, but lately I've felt disappointed with how gross templates get, and how complex the stack has become. I would conform more closely to C, but managing memory without any destructors (or ~defer~, etc.) is a definite pain point.

* The test
- Write a command-line tool which takes several optional arguments
- The tool creates and manipulates numeric data based on the arguments, then serializes the data to a file
- The file should include several different fields and a string or something (i.e. not a perfect 4-byte float dump)
- The tool can load from the file and manipulate that data

The test program would be a pain in the ass to write in C, which is what I'm trying to beat.
* The languages
** Zig
- [[https://ziglang.org/][Homepage and overview]]
- [[https://ziglang.org/download/][Download]]
- [[https://ziglang.org/documentation/master/][Documentation]]
- [[https://github.com/ziglang/zig][Repository]]

Zig uses LLVM to generate machine code. It also uses LLVM to handle C interoperability.
** Carp
- [[https://github.com/carp-lang/Carp][Repository]]
- [[https://github.com/carp-lang/Carp/blob/master/docs/LanguageGuide.md][Language guide]]

Carp compiles into C, then uses a C compiler to create the machine code.
** Steel Bank Common Lisp (SBCL)
- [[http://www.sbcl.org/][Homepage]]
- [[http://www.sbcl.org/platform-table.html][Download]]
- [[https://sourceforge.net/p/sbcl/sbcl/ci/master/tree/][Repository]]
- [[http://sbcl.org/manual/index.html][Manual]]
- [[http://www.gigamonkeys.com/book/][Practical Common Lisp]]

SBCL has its own machine-code compiler.

*** Additional setup
[[https://www.quicklisp.org/beta/][Install Quicklisp]].
** /Explanation/
I selected Zig because it takes performance seriously, and has compilation-time code execution support. I'm also a Zig sponsor, so I wanted to do this project to try out what I'm supporting :). I didn't pick Rust because I don't think the memory management overhead is worth it. I'm no expert on that though, so I could be very wrong.

I picked two Lisp-y languages because I'm enticed by the talk of how powerful it is (I love the idea of [[https://en.wikipedia.org/wiki/Game_Oriented_Assembly_Lisp][GOAL]]), and how you can extend the language within the language. I also like that most Lisps have compile-time code execution and hotreloading. The former is good for things like serialization which are common in games but very painful in C/C++. It's also nice to make things more automatic, like module initialization. Hotreloading is good for drastically shortening the iteration time.

My biggest criticisms of Lisps is how much they rely on garbage collection and data structures with poor cache characteristics (linked lists). I'm hoping Carp will give me the best of both worlds (no GC, but still Lisp-y) there. SBCL is the closest to a "normal" Lisp in case I do find it acceptable performance-wise.
* Results
** Features
These are features important to me to have:

| Language | Has REPL | Has hot-reloading | Introspection     | Compile-time code generation | Memory management¹       |
|----------+----------+-------------------+-------------------+------------------------------+--------------------------|
| Zig      | No       | No                | Yes, without tags | Yes                          | [[https://ziglang.org/documentation/master/#Memory][All manual. Explicit]]     |
| Carp     | Yes      | No                |                   |                              | [[https://github.com/carp-lang/Carp]["Automatic", no GC]]       |
| SBCL     | Yes      | Yes               |                   |                              | Garbage-collected ([[https://www.cons.org/cmucl/doc/gc-tuning.html][a]], [[https://medium.com/@MartinCracauer/llvms-garbage-collection-facilities-and-sbcl-s-generational-gc-a13eedfb1b31][b]]) |

¹I'm usually working on high-performance apps like games, so it is important that I have fine-grained control over memory and can reliably avoid stalls. The language should help me achieve high performance without making me suffer for it, one way or another (hard implementation vs. bad runtime performance).

*** C interoperability
C holds such a massive amount of value to interface with, especially in game development (e.g. most console SDKs are written in C++, which is different from C but can be interfaced with through C wrappers).

**** Zig
- [[https://ziglang.org/#Integration-with-C-libraries-without-FFIbindings][Zig's summary of its C library interoperability]]
- [[https://ziglang.org/documentation/master/#C][More documentation on C interop]]

This is a huge plus to Zig, because writing bindings is tedious and gratuitous.

Zig also has excellent C ABI export ability, meaning if I write a bunch of Zig code, then switch back to C or C++, I will still be able to reasonably use that Zig code - no "boxing", weird conversions, etc. necessary.
**** Carp
**** SBCL
** My Implementations

| Language | My CLOC | Time to implement | Executable size |
|----------+---------+-------------------+-----------------|
| Zig      |         | 1h                |                 |
| Carp     |         |                   |                 |
| SBCL     |         |                   |                 |

*** Zig
- Right out of the box, the [[https://ziglang.org/documentation/master/][Hello World documentation]] did not compile against my installed version. It's a rapidly changing language, so it's not unexpected, but a little annoying. I'm building my documentation from my source now, so I shouldn't have this problem again
- I like that what type of allocator I'm using is very explicit (I'm using [[https://github.com/ziglang/zig/blob/master/doc/docgen.zig][docgen.zig]] as a reference for my test). [[https://ziglang.org/documentation/master/#Choosing-an-Allocator][Choosing an Allocator]] makes me happy to have that level of control
- I like the ~defer~ keyword already, though by default it seems there's no errors or warnings if I omit it (and the memory should be freed)
- The Emacs ~zig-mode~ works quite well. Once I specified the ~zig-zig-bin~ variable, I got automatic formatting on save, which is pretty slick. I'm not a huge fan of the format style, but if it's not up to me I won't worry about it
- I managed to crash the compiler deep in LLVM output. I'm writing up a repro

**** Field and function tags, a.k.a. annotations
I was bummed to see struct field and function annotations/tags not available yet, and it probably won't be coming soon. [[https://github.com/ziglang/zig/issues/1099][See the issue]]. The issue author and I have the exact same use-case: automatic serialization and function command registration. 

The commentator who said "serialization should be written by hand each time" is flat wrong: serialization is extremely boilerplate-y and painful to write. We should make the computer do that mindless work!

I think I can get by via the ~@typeName~ builtin as well as external metadata structures for field tagging, but it is a damn shame the tags approach had so many detractors.

For an example of how it is useful, see how Unreal Engine 4 uses ~USTRUCT~ to generate whole editors from field tags, among other things:
- [[https://docs.unrealengine.com/en-US/Programming/UnrealArchitecture/Reference/Properties/Specifiers/index.html][Property specifiers]]
- [[https://docs.unrealengine.com/en-US/Programming/UnrealArchitecture/Reference/Classes/Specifiers/index.html][Class specifiers]]
- [[https://docs.unrealengine.com/en-US/Programming/UnrealArchitecture/Reference/Functions/Specifiers/index.html][Function specifiers]]

*** SBCL
- Emacs Slime got me up and running quickly, though I'm going to have to redefine a bunch of keys. I'm used to certain completion keybinds that I'll have to bind over whatever slime has
- It's very frustrating to find the documentation. When I do find some, the answers involve piling on various external packages to make it easier, thus making the whole system more complex. In comparison, Zig is all on one page, and has plenty of easy-to-understand examples
** Maintainability/sustainability

| Language | CLOC  | Repo health                                           | Ecosystem                        | Comments                                             |
|----------+-------+-------------------------------------------------------+----------------------------------+------------------------------------------------------|
| Zig      | 84k¹  | Very active. Healthy, financially supported           | Small, though C can be used      |                                                      |
| Carp     | 27k   | Not many contributors. Says it's a "research project" | Very small, though C can be used | Likely to die as soon as its solo dev loses interest |
| SBCL     | 490k² | Old! Still active, many contributors                  | Large: Common Lisp packages      | Porting would be hard because it's a custom compiler |

¹CLOC did not detect Zig as a language, though I think it did count the Zig files as C/C++ files. I used ~cloc src/ src-self-hosted/ lib/std/~ to count the source code I thought was most representative of zig (this does not include LLVM/libc/other dependencies)
²Unlike Zig and Carp, the SBCL CLOC does include a full compiler. ~447k of SBCL is written in Lisp, i.e. the language itself, whereas Zig's compiler is in C++ and Carp's is in Haskell

Note that I mean no disrespect with these evaluations, I'm only trying to be realistic about whether I would need to become the maintainer of the language in e.g. 5 or 10 years time.
